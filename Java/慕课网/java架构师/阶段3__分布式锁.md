## 阶段3_分布式锁

### 超卖解决方法

#### 解决方法1

1. 扣减库存不在程序中进行，而是通过数据库
2. 向数据库传递库存增量，扣减1个库存，增量为-1
3. 在数据库update语句计算库存，通过update行锁解决并发

#### 解决方法2

- 校验库存、扣减库存统一加锁
- 使之成为原子性的操作
- 并发时，只有获得锁的线程才能校验、扣减库存
- 扣减库存结束后，释放锁
- 确保库存不会扣成负数

##### 基于Synchronized锁解决超卖问题（最原始的锁）

事务如果用注解，则不在锁内

自己再程序里加锁

方法锁，块锁

##### 基于ReentrantLock锁解决超卖问题（并发包中的锁）

### 

#### 基于数据库实现分布式锁的步骤

- 多个进程、多个线程访问共同组件数据库
- 通过select......for update 访问同一条数据
- for update锁定数据，其他线程只能等待

##### 优缺点

- 优点：简单方便、易于理解、易于操作
- 缺点：并发量大时，对数据库压力较大
- 建议：作为锁的数据库与业务数据库分开

#### 基于Redis的setnx实现分布式锁

- 获取锁的Redis命令
- SET resource_name my_random_value NX PX 30000
- resource_name：资源名称，可根据不同的业务区分不同的锁
- my_random_value：随机值，每个线程的随机值都不同，用于释放锁时的校验
- NX：key不存在时设置成功，key存在则设置不成功
- PX：自动失效时间，出现异常情况，锁可以过期失效

##### 原理

- 利用NX的原子性，多个线程并发时，只有一个线程可以设置成功
- 设置成功即获得锁，可以执行后续的业务处理
- 如果出现异常，过了锁的有效期，锁自动释放
- 释放锁采用Redis的delete命令
- 释放锁时校验之前设置的随机数，相同才能释放
- 释放锁的LUA脚本

##### 经验

并发请求过来了，到redis里都变成顺序的了，并行变成了串行，因为redis是单线程的

### 基于分布式锁解决定时任务重复问题

### 基于zookeeper实现分布式锁

#### 实现原理

- 利用zookeeper的瞬时有序节点的特性
- 多线程变法创建瞬时节点时，得到有序的序列
- 序号最小的线程获得锁
- 其他的线程则监听自己序号的前一个序号

### redission

- idea使用autowired有红线，是因为idea不能识别xml

### 分布式锁实现方案的对比

- 数据库
  - 实现简单，易于理解
  - 对数据库压力大
- Redis
  - 易于理解
  - 自己实现，不支持阻塞
- zookeeper
  - 支持阻塞
  - 需理解zookeeper，程序复杂
- curator
  - 提供锁的方法
  - 依赖zookeeper，强一致
- redission
  - 提供锁的方法，可阻塞

#### 总结

- 不推荐自己编写的分布式锁
- 推荐Redission和Curator实现的分布式锁

