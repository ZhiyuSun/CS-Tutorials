## Java泛型、反射、编译优化

### 1. 实现了Srializable接口却报错怎么办？

序列化和反序列化

- 序列化：将对象写入到IO流中
- 反序列化：从IO流中恢复对象

### 2. 泛型不仅仅是规定集合中的类型那么简单

泛型

- 泛型就是参数化类型，就是讲类型由原来的具体的类型参数化
- 为什么使用泛型：能够在不创建新类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型

java中的 泛型是伪泛型，把真实的类型擦除掉了

泛型的特性：

- 先检查再编译
- 泛型不支持继承
- 不能是基本数据类型
- 泛型的类型参数只能是类类型，不能是简单类型

### 3. 使用原始类型可能出现灾难性后果

优化建议：

- 初步优化：使用List<Object>至少明确告诉编译器，容器中可以存放任意类型的对象
- 更进一步优化：明确的指定具体的类型，把类型检查的工作交给编译器来完成，List<People>

### 4. 反射获取不到Method是为什么

反射

- 允许运行中的 Java程序获取自身的信息，并可以操作类或对象的内部属性

应用场景：

- 开发通用框架
- 动态代理
- 注解
- 可扩展性功能

反射同样存在着缺陷：

- 性能开销
- 破坏封装性
- 内部曝光

类加载过程

Method类

- 提供一个类的方法的信息以及访问类的方法的接口
- Class获取Method：getMethod，getDelaredMethod，。。。

什么场景下反射获取不到Method

- 当方法是基本类型时，反射获取Method的参数类型也必须一致
- 如果调用的方法属于当前对象的父类，那么getDeclaredMethod获取不到Method

### 5. 并不是所有的字符串拼接都是要StringBuilder

使用“+”去拼接字符串，会造成怎样的性能损失

- 空间浪费：每次拼接的结构都需要创建新的不可变类
- 时间浪费：创建的新的不可变类需要初始化，产生大量临时对象，影响young gc，甚至full gc
- 尽量不要依赖编译器去做string拼接优化

StringBuffer和StringBuilder的三个区别

- 线程安全：StringBuffer线程安全；StringBuilder线程不安全
- 缓冲区：StrngBuffer使用缓冲区；StrngBuilder不适用缓冲区
- 性能：StrngBuilder性能远大于StringBuffer

### 6. 分不清深浅拷贝，稍不留神就会吃亏

什么是深浅拷贝

Cloneable接口

- 从JVM的角度看，Cloneable就是一个标记接口，它自身并没有定义任何的方法签名，clone方法是定义在Object中的，不要混淆

- 如果类没有实现Cloneable接口，直接调用Object的clone方法，会抛出异常

- Object提供的clone方法是浅拷贝

  