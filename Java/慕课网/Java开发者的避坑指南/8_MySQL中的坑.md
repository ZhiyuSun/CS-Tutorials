## MySQL中常见的坑

### 1. 表属性设置为NULL，你可能要面临很多麻烦

为什么会有很多人用NULL呢？

- NULL是默认行为，如果你不指定列字段是NOT NULL的，那么，它就是NULL的
- 一个很严重的误区：NULL不占用存储空间（是一种优化行为）
- NULL属性非常方便，SQL语句或者代码不需要额外的填充或判断

NULL列存在的问题，容易引起BUG的特性

- NULL列需要你关注的地方
  - NULL的长度并不是0
  - NULL参与的查询
    - is null，is not null
    - == 'xyz'等价于==
  - NULL对索引的影响
    - 只有is null 时才会使用索引
    - 唯一性索引对NULL不生效
    - desc命令
  - NULL参与计算
    - null值与其他值计算，结果总会一个null
  - NULL参与聚合
    - count(column)，null列不参与统计
  - NULL参与排序
    - asc，null在所有行之前
    - desc，null在所有行之后

我应该用什么去代替NULL呢？

- 使用特殊值去填充NULL，例如：空字符串（字符类型）或者数字0（数字类型）
- 对于已经存在数据的表，填充特殊值到NULL列，再去修改表结构（列限制）
- 记住：任何场景下你都不应该考虑使用NULL。NULL存在各种各样的问题

### 2. 不再随意设置数据类型，不给未来留隐患

选择列的数据类型，先从主键开始

- 虽然MySQL允许创建表时不指定主键，但是一定要指定一个主键
- 如果你没有指定主键——是否存在非空整型唯一索引（成为主键）——否的话，InnoDB自动添加隐式主键
- 主键不具有任何的业务含义，只是一个唯一的自增整数值

选择合适的数据类型以及恰当的范围

- MySQL中定义了四类数据类型，且有不同的取值范围
  - 字符串：char,varchar,tinytext,text,mediumtext,longtext
  - 日期/时间：date，time，datetime，timestamp
  - 数值：tinyint，int，bigint,float，double,decimal
  - 二进制：tinyblob，blob,mediumblob,longblob
- 不要使用枚举ENUM
  - 枚举类型的值都是从“允许值列表”中选择，且这个列表是在创建表结构时就定义好的，它有两大优势。
    - 存储数字，数据更加紧凑
    - 允许值提前定义，MySQL可以检查数据正确性
  - pic

数据类型选择与使用上的技巧与建议

- 使用存储所需要的最小数据类型
- 选择简单的数据类型
- 存储小数直接选择decimal
- 尽量避免使用text和blob

### 3. 索引加的不好，效果可能适得其反

索引加的正确，但是没有写出适用索引的查询语句

- show index from xxx;
- 字符串类型在查询时没有使用引号，不会使用表索引。
  - explain sql
- where条件左边字段参与了函数或者数学运算，不会使用表索引
- 联合索引最左前缀顺序不匹配，不会使用表索引

索引加的不正确/冗余

- 不再使用的索引没有及时删除：空间浪费、插入删除更新性能受影响、MySQL维护索引也需要消耗资源
- 索引选择性太低，索引列的意义不大。索引选择性=不重复的索引值/表记录数
- 列值过长，可以选择部分前缀作为索引（区分度高的情况下），而不是整列加上索引。
- 表记录比较少，全表扫描效率更高（这是相对的），我个人的经验是1000行为界限。
- 存在联合索引的情况下，再去对前缀部分加索引（已经覆盖了单列或者多列索引），是没有意义的
- 一张表中建立的索引过多（超过5个），应该是根据业务需求去分析创建，并不是越多越好，太多会浪费空间，影响额外的查询效率

### 4. MYSQL为什么莫名其妙的断开连接

为什么连接会断开

- MySQL默认的连接超时（服务没有收到请求，距离上一次交互）时间是8个小时
- jdbc

autoReconnect存在的一些副作用

- 原有连接上的事务将会被回滚，事务的提交模式将会丢失
- 原有连接中持有的表的锁将会全部释放
- 原有连接关联的会话session将会丢失，重新恢复的连接关联的将是一个全新的会话session
- 原有连接中的定义的用户变量将会丢失
- 原有连接中定义的预编译SQL将会丢失
- 原有连接失效，新的连接恢复之后，MySQL将使用新的记录行来存储连接中的性能数据

修改Mysql配置，避免断开连接

- Mysql中关于连接的两个核心变量
  - interactive_timeout
  - wait_timeout
- 如何修改
  - SET GLOABL
  - 配置文件

数据库连接池HikariCP配置

- maximum-pool-size：最大的连接数目。超过这个数目，新的数据库访问线程会被阻塞。推荐：((core_count*2) + effective_spindle_count)
- minimum-idle：最小的连接数目
- max-lifetime：最大的连接生命时间，用来设置一个connection在连接池中的存活时间
- idle-timeout：一个连接idle状态的最大时长，超时则被释放（retired）
  - 生效的条件：minimum-idle < maximum-pool-size && idle-timeout >0

### 5. 事务处理出错？可能是锁用的不对

数据库锁的分类

- 按照锁数据的粒度（等级）去分
  - 行级锁
  - 表级锁（容易出现死锁）
- 按照数据的锁定方式去分
  - 乐观锁（CAS：compare and set）
  - 悲观锁
    - 排他锁（selelct for update）
      - 其他事务想在设置排他锁时必须要等其他的排他锁释放
    - 共享锁（lock in share mode）

行锁的并发性能远高于表锁，但是小心粒度升级

- InnoDB只有在通过索引条件检索数据时使用行级锁，否则使用表锁
  - InnoBD的行锁是针对索引加的锁，不是针对记录加的锁
- 对于update、delete和insert语句，inndb会自动给涉及数据集加排它锁，对普通select语句，innodb不会加任何锁

验证的时候，可以set-autocommit为false

### 6. 你写的SQL可能很慢，怎样做优化呢？

怎样配置MySQL定位执行慢的查询

- slow_query_log：标记慢查询日志是否开启的参数，默认是OFF，即不开启
- slow_query_log_file：标记存放慢查询日志文件的完整路径（注意权限问题）
- long_query_time：控制慢查询的时间阈值参数
- log_queries_not_using_indexex：标识是否记录未使用索引的查询，默认是关闭

使用mysqldumpslow工具解读慢查询日志

（图）

使用explain/desc分析执行的SQL语句

慢查询问题总结建议

- select太多数据行、数据列（大数据量查询）
- 没有定义合适的索引
- 没有按照索引定义的顺序查询
- 定义了索引，但是MySQL并没有选择
- 复杂查询

### 7. 数据量主键增大，才考虑分库分表可行吗

业务发展过程中遇到了哪些问题

- 随着业务的增长，数据量急剧膨胀，查询、迁移都会变得非常麻烦，最经典的例子是用户表和订单表
- 表设计的不合理，在使用过程中发现问题（列太多，且99%的查询大部分的列不会被用到）
- 可以考虑分库分表解决这些问题

分库分表的策略

- 垂直切分：可以同时作用于库和表
  - 电商系统（用户信息库，商品及订单库，附属信息库）
  - 优点：
    - 消除库中存在的业务表耦合，使数据表之间的关系更加的清晰
    - 将数据库的连接资源、单机硬件资源隔离开，更利于业务的扩展
  - 缺点：
    - 表与表之间很难做到完整的JOIN，只能通过多次查询的方式聚合数据
    - 查询多个表会将单标事务升级为分布式事务，实现难度大大增加
    - 仍然可能会存在单表数据量过大的问题
- 水平切分：只适用于数据表
  - 水平切分规则
    - 按照时间区分或者自增id来切分
    - 哈希取模切分

分库分表引发的问题

- 全局主键问题
  - UUID（通用唯一识别码）
  - 额外的自增表
  - 分布式全局唯一ID生成算法
- 事务一致性问题
  - XA协议
  - 2PC（两阶段提交）
  - 3PC（三阶段提交）
- 关联查询（JOIN）问题
  - 字段冗余设计
  - 数据组装（后端）
  - 拆分查询（前端）

