## Java空指针和异常

### 1. 如何从根源避免空指针

空指针的几种情况：

- 调用了空对象的实例方法
- 访问了空对象的属性
- 当数组是一个空对象的时候，取它的长度
- null当做 Throwable 的值
- 方法的返回值是null，调用方直接去使用

如何避免：

- 使用前一定要初始化，或检查是否初始化
- 尽量避免在函数中返回null，或给出详细的注释（良好的编程习惯）
- 外部传值，除非有明确的说明（非FULL），否则，一定要及时判断

### 2. 赋值时自动拆箱出现空指针

让基本类型具有对象的特征，于是有了包装类型

场景：

- 变量赋值自动拆箱出现的空指针
- 方法传参时自动拆箱引发的空指针
- 用于大小比较的场景

如何避免：

- 基本数据类型优于包装器类型，优先考虑使用基本类型
- 对于不确定的包装器类型，一定要校验是否是NULL
- 对于值为NULL的包装器类型，赋值为0

### 3. 字符串、数组、集合在使用时出现空指针怎么办

场景：

- 字符串使用equals可能会报空指针错误
- 对象数组虽然new出来了，但是元素没有初始化，一样会报空指针错误
- List对象add null不报错，但是addAll不能添加null，否则会报空指针错误

### 4. 使用Optional规避空指针时，需要注意些什么？

- 与直接and是否是NULL几乎一样，所以，使用新的API意义不大。
- 认识到orElse、orElseGet、map等方法的妙用
- get、ifPresent这样的方法更应该看作是私有（不要直接去使用）方法

### 5. 明明try catch了却没有解决好异常

实践原则：

- 使用异常，而不是返回码（或类似），因为异常会更加的详细
- 主动捕获检查性异常，并对异常信息进行反馈（日志或标记）
- 保持代码整洁，一个方法中不要有多个try catch或者嵌套的try catch
- 捕获更加具体的异常，而不是通用的Exception
- 合理的设计自定义的异常类

### 6. 并发修改、类型转换、枚举查找

- 可迭代对象在遍历的同时做修改，则会报并发修改异常
  - 在for循环里迭代删除会触发并发修改异常，可使用迭代器解决Iterator，或者用stream
- 类型转换不符合Java的继承关系，则会报类型转换异常
  - user.getClass().getName()
  - user insanceof Manager
- 枚举在查找时，如何枚举值不存在，不会返回空，而是直接抛出异常
  - try——catch捕获异常
  - 遍历枚举值，但是效率不高
  - 构建一个静态Map索引
  - 使用Google Guava Enums，需要相关的依赖

### 7. 解决使用try finally 的资源泄露隐患

try finally的问题及改进方案

- 对单个资源的操作基本不会有问题
- 当同时操作多个资源时，代码冗长，且存在泄露的风险
- try-with-resources不仅比try-finally方便，而且不容易出错

### tips

- javac xx.java 获得class文件
- javap -c xx.class 反解析汇编代码
- optional
- 学习java异常处理的层级

